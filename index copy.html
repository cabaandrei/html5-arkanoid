<!DOCTYPE html>
<html>

<head>
    <title>JS Arkanoid Block Breaker</title>
    <style>
        /* Minimal CSS to center the game */
        body {
            background: #eee;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            font-family: sans-serif;
            flex-direction: column;
        }

        #gameCanvas {
            border: 5px solid #333;
            background: #000;
            /* Black background for the game area */
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        h1 {
            color: #333;
        }
    </style>
</head>

<body>
    <h1>Classic JS Arkanoid</h1>
    <!-- <canvas id="gameCanvas" width="480" height="320"></canvas> -->
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script>
        // --- Game Initialization and Constants ---
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");

        // Scalable base dimensions
        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;

        const scaleX = canvasWidth / 480;
        const scaleY = canvasHeight / 320;

        // Ball properties
        let ballRadius = 10 * scaleX;
        let x = canvasWidth / 2;
        let y = canvasHeight - 30 * scaleY;
        let dx = 2 * scaleX;
        let dy = -2 * scaleY;

        // Paddle properties
        const paddleHeight = 10 * scaleY;
        const paddleWidth = 75 * scaleX;
        let paddleX = (canvasWidth - paddleWidth) / 2;

        // Input control variables
        let rightPressed = false;
        let leftPressed = false;

        // Bricks properties
        const brickRowCount = 3;
        const brickColumnCount = 5;
        const brickWidth = 75 * scaleX;
        const brickHeight = 20 * scaleY;
        const brickPadding = 10 * scaleX;
        const brickOffsetTop = 30 * scaleY;
        const brickOffsetLeft = 30 * scaleX;

        const bricks = [];
        for (let c = 0; c < brickColumnCount; c++) {
            bricks[c] = [];
            for (let r = 0; r < brickRowCount; r++) {
                bricks[c][r] = { x: 0, y: 0, status: 1 };
            }
        }

        // --- Input Handlers ---
        document.addEventListener("keydown", keyDownHandler, false);
        document.addEventListener("keyup", keyUpHandler, false);
        document.addEventListener("mousemove", mouseMoveHandler, false);

        function keyDownHandler(e) {
            if (e.key === "Right" || e.key === "ArrowRight") rightPressed = true;
            else if (e.key === "Left" || e.key === "ArrowLeft") leftPressed = true;
        }

        function keyUpHandler(e) {
            if (e.key === "Right" || e.key === "ArrowRight") rightPressed = false;
            else if (e.key === "Left" || e.key === "ArrowLeft") leftPressed = false;
        }

        function mouseMoveHandler(e) {
            let relativeX = e.clientX - canvas.offsetLeft;
            if (relativeX > 0 && relativeX < canvasWidth) {
                paddleX = relativeX - paddleWidth / 2;
                if (paddleX < 0) paddleX = 0;
                if (paddleX + paddleWidth > canvasWidth) paddleX = canvasWidth - paddleWidth;
            }
        }

        // --- Drawing Functions ---
        function drawBall() {
            ctx.beginPath();
            ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
            ctx.fillStyle = "#FF4500";
            ctx.fill();
            ctx.closePath();
        }

        function drawPaddle() {
            ctx.beginPath();
            ctx.rect(paddleX, canvasHeight - paddleHeight, paddleWidth, paddleHeight);
            ctx.fillStyle = "#0095DD";
            ctx.fill();
            ctx.closePath();
        }

        function drawBricks() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    if (bricks[c][r].status === 1) {
                        let brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft;
                        let brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;
                        bricks[c][r].x = brickX;
                        bricks[c][r].y = brickY;
                        ctx.beginPath();
                        ctx.rect(brickX, brickY, brickWidth, brickHeight);
                        ctx.fillStyle = "#00DD66";
                        ctx.fill();
                        ctx.closePath();
                    }
                }
            }
        }

        // --- Collision Detection ---
        function collisionDetection() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const b = bricks[c][r];
                    if (b.status === 1) {
                        if (
                            x + ballRadius > b.x &&
                            x - ballRadius < b.x + brickWidth &&
                            y + ballRadius > b.y &&
                            y - ballRadius < b.y + brickHeight
                        ) {
                            const overlapLeft = x + ballRadius - b.x;
                            const overlapRight = b.x + brickWidth - (x - ballRadius);
                            const overlapTop = y + ballRadius - b.y;
                            const overlapBottom = b.y + brickHeight - (y - ballRadius);
                            const minOverlapX = Math.min(overlapLeft, overlapRight);
                            const minOverlapY = Math.min(overlapTop, overlapBottom);
                            if (minOverlapX < minOverlapY) dx = -dx;
                            else dy = -dy;
                            b.status = 0;
                        }
                    }
                }
            }
        }

        // --- Main Game Loop ---
        function draw() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            drawBricks();
            drawBall();
            drawPaddle();
            collisionDetection();

            let nextX = x + dx;
            let nextY = y + dy;

            if (nextX > canvasWidth - ballRadius || nextX < ballRadius) dx = -dx;
            if (nextY < ballRadius) dy = -dy;

            if (
                nextY + ballRadius >= canvasHeight - paddleHeight &&
                nextY + ballRadius <= canvasHeight &&
                nextX > paddleX &&
                nextX < paddleX + paddleWidth
            ) {
                const hitPoint = nextX - (paddleX + paddleWidth / 2);
                const normalized = hitPoint / (paddleWidth / 2);
                dx = normalized * 4 * scaleX;
                dy = -Math.abs(dy);
            } else if (nextY + ballRadius > canvasHeight) {
                alert("GAME OVER! Try again!");
                document.location.reload();
                return;
            }

            if (rightPressed && paddleX < canvasWidth - paddleWidth) paddleX += 7 * scaleX;
            else if (leftPressed && paddleX > 0) paddleX -= 7 * scaleX;

            x += dx;
            y += dy;

            requestAnimationFrame(draw);
        }

        draw();
    </script>

</body>

</html>